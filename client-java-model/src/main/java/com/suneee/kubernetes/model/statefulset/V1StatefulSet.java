/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.11.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.suneee.kubernetes.model.statefulset;

import com.google.gson.annotations.SerializedName;
import com.suneee.kubernetes.constant.ImagePullPolicy;
import com.suneee.kubernetes.custom.IntOrString;
import com.suneee.kubernetes.custom.Quantity;
import com.suneee.kubernetes.model.*;
import com.suneee.kubernetes.model.container.V1Container;
import com.suneee.kubernetes.model.container.V1ContainerPort;
import com.suneee.kubernetes.model.deployment.AppsV1beta1Deployment;
import com.suneee.kubernetes.model.persistentvolume.V1PersistentVolumeClaim;
import com.suneee.kubernetes.model.persistentvolume.V1PersistentVolumeClaimVolumeSource;
import com.suneee.kubernetes.model.secret.V1SecurityContext;
import com.suneee.kubernetes.model.volume.V1Volume;
import com.suneee.kubernetes.model.volume.V1VolumeMount;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.util.*;

/**
 * StatefulSet represents a set of pods with consistent identities. Identities are defined as:  - Network: A single stable DNS and hostname.  - Storage: As many VolumeClaims as requested. The StatefulSet guarantees that a given network identity will always map to the same storage identity.
 */
@ApiModel(description = "StatefulSet represents a set of pods with consistent identities. Identities are defined as:  - Network: A single stable DNS and hostname.  - Storage: As many VolumeClaims as requested. The StatefulSet guarantees that a given network identity will always map to the same storage identity.")

public class V1StatefulSet {
  @SerializedName("apiVersion")
  private String apiVersion = null;

  @SerializedName("kind")
  private String kind = null;

  @SerializedName("metadata")
  private V1ObjectMeta metadata = null;

  @SerializedName("spec")
  private V1StatefulSetSpec spec = null;

  @SerializedName("status")
  private V1StatefulSetStatus status = null;

  public V1StatefulSet apiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
    return this;
  }

  public V1StatefulSet(){
    this.apiVersion = "apps/v1";
    this.kind = "StatefulSet";
    this.metadata = new V1ObjectMeta();
    this.spec = new V1StatefulSetSpec();

  }

  public V1StatefulSet(String namespace,String name){
    this();
    setNamespace(namespace);
    setName(name);
  }

  public void setNamespace(String namespace){
    metadata.setNamespace(namespace);
  }

  public String getNamespace(){
    return metadata.getNamespace();
  }

  public void setName(String name){
    metadata.setName(name);
    Map<String,String> labels = new HashMap<>();
    labels.put("app",name);
    metadata.setLabels(labels);

    Map<String,String> labelsspec = (Map<String, String>) ((HashMap<String, String>) labels).clone();
    spec.getTemplate().getMetadata().setLabels(labelsspec);
  }

  public String getName(){
    return metadata.getName();
  }

  public void setReplicas(Integer replicas){
    spec.setReplicas(replicas);
  }


  public V1StatefulSet setRevisionHistoryLimit(Integer revisionHistoryLimit){
    spec.setRevisionHistoryLimit(revisionHistoryLimit);
    return this;
  }

  public V1StatefulSet addContainer(V1Container container) {
    spec.getTemplate().getSpec().addContainersItem(container);
    return this;
  }

  public V1StatefulSet cleanEnv(){
    return cleanEnv(0);
  }

  public V1StatefulSet cleanEnv(int index){
    if (spec.getTemplate().getSpec().getContainers().get(index) != null){
      spec.getTemplate().getSpec().getContainers().get(index).env(new ArrayList<V1EnvVar>());
    }
    return this;
  }

  public V1StatefulSet addEnv(String key,String value){
    return addEnv(0,key,value);
  }

  public V1StatefulSet addEnv(int index,String key,String value){
    if (spec.getTemplate().getSpec().getContainers().get(index) != null){
      spec.getTemplate().getSpec().getContainers().get(index).addEnvItem(new V1EnvVar(key,value));
    }
    return this;
  }

  public V1StatefulSet addPort(int port){
    return addPort(0,port);
  }

  public V1StatefulSet addPort(int index,int port){
    if (spec.getTemplate().getSpec().getContainers().get(index) != null){
      deletePort(index,port);
      spec.getTemplate().getSpec().getContainers().get(index).addPortsItem(new V1ContainerPort().containerPort(port));
    }
    return this;
  }

  public V1StatefulSet deletePort(int port){
    return deletePort(0,port);
  }

  public V1StatefulSet deletePort(int index,int port){
    if (spec.getTemplate().getSpec().getContainers().get(index) != null){
      List<V1ContainerPort> portList = spec.getTemplate().getSpec().getContainers().get(index).getPorts();
      if (portList != null){
        for (int i = 0; i < portList.size(); i++) {
          V1ContainerPort containerPort = portList.get(i);
          if (containerPort.getContainerPort() == port){
            portList.remove(i);
            break;
          }
        }
      }
    }
    return this;
  }

  public V1StatefulSet setResource(String limitsCpu,String limitsmem){
    return setResource(0,limitsCpu,limitsmem);
  }

  public V1StatefulSet setResource(String limitsCpu,String limitsmem,String requestsCpu,String requestsmen){
    return setResource(0,limitsCpu,limitsmem,requestsCpu,requestsmen);
  }

  public V1StatefulSet setResource(int index,String limitsCpu,String limitsmem){
    return setResource(index,limitsCpu,limitsmem,null,null);
  }

  public V1StatefulSet setResource(int index,String limitsCpu,String limitsmem,String requestsCpu,String requestsmen){
    if (spec.getTemplate().getSpec().getContainers().get(index) != null){
      V1ResourceRequirements resource = new V1ResourceRequirements();
      if (limitsCpu != null && !limitsCpu.isEmpty()){
        resource.putLimitsItem("cpu",new Quantity(limitsCpu));
      }
      if (limitsmem != null && !limitsmem.isEmpty()){
        resource.putLimitsItem("memory",new Quantity(limitsmem));
      }
      if (requestsCpu != null && !requestsCpu.isEmpty()){
        resource.putRequestsItem("cpu",new Quantity(requestsCpu));
      }
      if (requestsmen != null && !requestsmen.isEmpty()){
        resource.putRequestsItem("memory",new Quantity(requestsmen));
      }
      spec.getTemplate().getSpec().getContainers().get(index).resources(resource);
    }
    return this;
  }

  public void addContainer(String name,String imagesName){
    addContainer(name,imagesName,null,null,null);
  }

  public void addContainer(String name,String imagesName,List<Integer> portList){
    addContainer(name,imagesName,portList,null,null);
  }

  public void addContainer(String name,String imagesName,List<Integer> portList,HashMap<String,String> envs){
    addContainer(name,imagesName,portList,envs,null);
  }

  public void addContainer(String name,String imagesName,Integer port,HashMap<String,String> envs){
    List<Integer> portList = new ArrayList<Integer>();
    portList.add(port);
    addContainer(name,imagesName,portList,envs,null);
  }

  public V1StatefulSet addContainer(String name, String imagesName, List<Integer> portList,HashMap<String,String> envs,V1ResourceRequirements resource){
    V1Container container = new V1Container();
    this.addContainer(container);
    container.setName(name);
    container.setImage(imagesName.toLowerCase());
    container.setImagePullPolicy(ImagePullPolicy.Always);
    if (portList != null && portList.size()>0){
      for (Integer port : portList) {
        container.addPortsItem(new V1ContainerPort().containerPort(port));
      }
      addReadinessProbe(portList.get(0));
      addLivenessProbe(portList.get(0));
    }

    if (envs != null && envs.size()>0){
      for (Map.Entry<String, String> entry : envs.entrySet()) {
        container.addEnvItem(new V1EnvVar(entry.getKey(),entry.getValue()));
      }
    }

    container.addEnvItem(new V1EnvVar("TZ","Asia/Shanghai"));

    int index = spec.getTemplate().getSpec().getContainers().size();
    setSecurityContext(index,0);

    if (resource != null) container.resources(resource);
    return this;
  }

  public V1StatefulSet updateImageName(String imageName){
    return updateImageName(0,imageName);
  }

  public V1StatefulSet updateImageName(int index,String imageName){
    spec.getTemplate().getSpec().getContainers().get(index).setImage(imageName);
    return this;
  }

  public V1StatefulSet addReadinessProbe(int port){
    return addReadinessProbe(0,port);
  }

  public V1StatefulSet addReadinessProbe(int index,int port){
    V1TCPSocketAction tcpSocket = new V1TCPSocketAction().port(new IntOrString(port));
    V1Probe probe = new V1Probe().tcpSocket(tcpSocket).initialDelaySeconds(30).timeoutSeconds(15).failureThreshold(6).periodSeconds(30);
    spec.getTemplate().getSpec().getContainers().get(index).readinessProbe(probe);
    return this;
  }

  public V1StatefulSet deleteReadinessProbe(){
    return deleteReadinessProbe(0);
  }

  public V1StatefulSet deleteReadinessProbe(int index){
    spec.getTemplate().getSpec().getContainers().get(index).readinessProbe(null);
    return this;
  }

  public V1StatefulSet addLivenessProbe(int port){
    return addLivenessProbe(0,port,600);
  }

  public V1StatefulSet addLivenessProbe(int port,int delaySecond){
    return addLivenessProbe(0,port,delaySecond);
  }

  public V1StatefulSet addLivenessProbe(int index,int port,int delaySecond){
    V1TCPSocketAction tcpSocket = new V1TCPSocketAction().port(new IntOrString(port));
    V1Probe probe = new V1Probe().tcpSocket(tcpSocket).initialDelaySeconds(delaySecond).timeoutSeconds(15).failureThreshold(3).periodSeconds(10);
    spec.getTemplate().getSpec().getContainers().get(index).livenessProbe(probe);
    return this;
  }

  public V1StatefulSet deleteLivenessProbe(){
    return deleteLivenessProbe(0);
  }

  public V1StatefulSet deleteLivenessProbe(int index){
    spec.getTemplate().getSpec().getContainers().get(index).livenessProbe(null);
    return this;
  }

  public V1StatefulSet cleanVolumes(){
    return cleanVolumes(0);
  }

  public V1StatefulSet cleanVolumes(int index){
    spec.getTemplate().getSpec().volumes(null);
    spec.getTemplate().getSpec().getContainers().get(index).volumeMounts(null);
    return this;
  }

  public V1StatefulSet setVolumes(String name,String claimName){
    List<V1Volume> list = spec.getTemplate().getSpec().getVolumes();
    boolean exists = false;
    if (list != null && list.size() > 0){
      for (V1Volume volume : list) {
        if (volume.getName().equals(name)){
          exists = true;
        }
      }
    }
    if (!exists){
      V1PersistentVolumeClaimVolumeSource claimVolumeSource = new V1PersistentVolumeClaimVolumeSource();
      claimVolumeSource.setClaimName(claimName);
      V1Volume volume = new V1Volume().name(name).persistentVolumeClaim(claimVolumeSource);
      spec.getTemplate().getSpec().addVolumesItem(volume);
    }
    return this;
  }

  public V1StatefulSet setVolumeMounts(String volumeName,String mountPath,String subPath){
    return setVolumeMounts(0,volumeName,mountPath,subPath);
  }

  public V1StatefulSet setVolumeMounts(int index,String volumeName,String mountPath,String subPath){
    V1VolumeMount mount = new V1VolumeMount().mountPath(mountPath).subPath(subPath).name(volumeName).readOnly(false);
    spec.getTemplate().getSpec().getContainers().get(index).addVolumeMountsItem(mount);
    return this;
  }

  public V1StatefulSet setVolumeMounts(String claimName,String volumeName,String mountPath,String subPath){
    return setVolumeMounts(0,claimName,volumeName,mountPath,subPath);
  }

  public V1StatefulSet setVolumeMounts(int index,String claimName,String volumeName,String mountPath,String subPath){
    setVolumes(volumeName,claimName);
    return setVolumeMounts(index,volumeName,mountPath,subPath);
  }

  public String getContainVersion(){
    return getContainVersion(0);
  }

  public String getContainVersion(int index){
    String imageName = spec.getTemplate().getSpec().getContainers().get(index).getImage();
    String version = imageName.substring(imageName.indexOf(":")+1,imageName.length());
    return version;
  }

  public V1StatefulSet addVolumeClaimTemplatesDefault(String cap){
    V1PersistentVolumeClaim pvc = new V1PersistentVolumeClaim().setName("data");
    pvc.setStorage(cap).setAccessModes("ReadWriteMany");
    spec.addVolumeClaimTemplatesItem(pvc);
    return this;
  }

  public V1StatefulSet setUpdateStrategy(String updateStrategy){
    V1StatefulSetUpdateStrategy statefulSetUpdateStrategy = new V1StatefulSetUpdateStrategy();
    statefulSetUpdateStrategy.setType(updateStrategy);
    spec.setUpdateStrategy(statefulSetUpdateStrategy);
    return this;
  }

  public V1StatefulSet setSecurityContext(int index,long roleId){
    V1SecurityContext securityContext = new V1SecurityContext();
    securityContext.setRunAsGroup(roleId);
    securityContext.setRunAsUser(roleId);
    spec.getTemplate().getSpec().getContainers().get(index).setSecurityContext(securityContext);
    return this;
  }


   /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
   * @return apiVersion
  **/
  @ApiModelProperty(value = "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources")
  public String getApiVersion() {
    return apiVersion;
  }

  public void setApiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
  }

  public V1StatefulSet kind(String kind) {
    this.kind = kind;
    return this;
  }

   /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   * @return kind
  **/
  @ApiModelProperty(value = "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds")
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }

  public V1StatefulSet metadata(V1ObjectMeta metadata) {
    this.metadata = metadata;
    return this;
  }

   /**
   * Get metadata
   * @return metadata
  **/
  @ApiModelProperty(value = "")
  public V1ObjectMeta getMetadata() {
    return metadata;
  }

  public void setMetadata(V1ObjectMeta metadata) {
    this.metadata = metadata;
  }

  public V1StatefulSet spec(V1StatefulSetSpec spec) {
    this.spec = spec;
    return this;
  }

   /**
   * Spec defines the desired identities of pods in this set.
   * @return spec
  **/
  @ApiModelProperty(value = "Spec defines the desired identities of pods in this set.")
  public V1StatefulSetSpec getSpec() {
    return spec;
  }

  public void setSpec(V1StatefulSetSpec spec) {
    this.spec = spec;
  }

  public V1StatefulSet status(V1StatefulSetStatus status) {
    this.status = status;
    return this;
  }

   /**
   * Status is the current status of Pods in this StatefulSet. This data may be out of date by some window of time.
   * @return status
  **/
  @ApiModelProperty(value = "Status is the current status of Pods in this StatefulSet. This data may be out of date by some window of time.")
  public V1StatefulSetStatus getStatus() {
    return status;
  }

  public void setStatus(V1StatefulSetStatus status) {
    this.status = status;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1StatefulSet v1StatefulSet = (V1StatefulSet) o;
    return Objects.equals(this.apiVersion, v1StatefulSet.apiVersion) &&
        Objects.equals(this.kind, v1StatefulSet.kind) &&
        Objects.equals(this.metadata, v1StatefulSet.metadata) &&
        Objects.equals(this.spec, v1StatefulSet.spec) &&
        Objects.equals(this.status, v1StatefulSet.status);
  }

  @Override
  public int hashCode() {
    return Objects.hash(apiVersion, kind, metadata, spec, status);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1StatefulSet {\n");

    sb.append("    apiVersion: ").append(toIndentedString(apiVersion)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    spec: ").append(toIndentedString(spec)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

